/*
	Calculates the absolute (positive) of the given number and returns it.

	Example::

		Abs(100)    // returns 100
		Abs(-100)   // returns 100
 */
public int Abs(int value)
{}

/*
	Adds node to the specified list after the node pointed to by nodeAfter.

	:param k_list list: A list (i.e. returned from :func:`NewList`).
	:param k_node nodeAfter: The node to insert after.
	:param k_node node: A node (i.e. returned from :func:`NewNode`).
	
	See also: :func:`AddToFront`, :func:`AddToEnd`, :func:`FindKey`, :func:`DeleteKey`
 */
public k_node AddAfter(k_list list, k_node nodeAfter, k_node node)
{
}

/*
	Adds a new menu item with the specified caption to the menubar.
	The string itemCaptions specifies the submenu items.
	The itemCaptions string can contain format characters to seperate items and format the text.    
	
	Format Characters:

	\`
		Tells the interpreter to right justify the following text

	\:
		Specifies the end of current item, the following will be the next item.

	--!
		Specifies that the menu item will just be a seperator.

	#	
		Specifies the item's function key.

	^
		Specifies the item's control+key combination.
	
	Example::
	
		AddMenu(
			" File "
			"Restart Game`#9:"+
			"Save Game`#5:"+
			"Restore Game`#7:"+
			"--! :"+
			"Quit`^q"
		)
 */
public void AddMenu(string caption, string itemCaptions)
{
}

/*
	Adds node to the end of the specified list.
	
	:param k_list list: A list (i.e. returned from :func:`NewList`).
	:param k_node node: A node (i.e. returned from :func:`NewNode`).

	See also:
	:func:`AddToFront`, :func:`AddAfter`, :func:`FindKey`, :func:`DeleteKey`
 */
public void AddToEnd(k_list list, k_node node)
{
}

/*
	Adds node to the front of the specified list.
	
	:param k_list list: A list (i.e. returned from :func:`NewList`).
	:param k_node node: A node (i.e. returned from :func:`NewNode`).

	See Also:
	:func:`AddAfter`, :func:`AddToEnd`, :func:`FindKey`, :func:`DeleteKey`
 */
public void AddToFront(k_list list, k_node node)
{
}

/*
	Draws the views contained in the viewList directly onto the picture
	as if they were originally part of the picture.
	They will stay there until the picture is discarded.

	:param k_list list: A list of object that inherit from :class:`View`.

	.. NOTE::
		In general, this should not be used. Instead, addToPic() on should be called on the individual :class:`View` objects instead.
		It will allow keeping the proper state across game save and restore.
*/
public void AddToPic(k_list pList)
{
}

/*
	Draws the background picture and foreground views.

	:param k_list cast: The game cast.
	:param boolean cycle: TRUE if the views be cycled.
	 
	If the background picture has not yet been drawn, it executes it's
	opening animation specified in the :func:`DrawPic` kernel call.
	If specified, it draws the views in the cast list on the foreground.
	
	If the cycle property is specified, and TRUE, it cycles the views as well, calling their doit() method.
*/
public void Animate(k_list cast, bool cycle)
void Animate(k_list cast)
void Animate()
{
}

/*
	Reads the views properties and generates it's bounding rectangle, storing
	it in the brLeft, brRight, brTop and brBottom properties.
	This rectangle is used for things such as collision detection.

	:param heapPtr view: An object that inherits from :class:`View`.
	
	See Also:
	:func:`View`
 */
public void BaseSetter(View view)
{
}


/*
	Checks the view to see if it is allowed to be at its current coordinates on the screen.

	.. IMPORTANT:: SCI0 only. For SCI1.1, see :func:`CantBeHere`.

	:param heapPtr view: An object that inherits from :class:`View`.
	:param k_list cast: Optional cast list.
	:returns: TRUE if it can be where it is, FALSE otherwise.
	
	.. NOTE::
		This is used in the class system when the object moves.
		If it can't be where it is, it sets it to it's previous coordinates.
		If castList is specified, it checks the viewObj against the objects in the list
		to see if it can be where it is. 
 */
public bool CanBeHere(View view)
bool CanBeHere(View view, k_list castList)
{
}

/*
	Checks the view to see if it is not allowed to be at its current coordinates on the screen.

	.. IMPORTANT:: SCI1.1 only. For SCI0, see :func:`CanBeHere`.

	:param heapPtr view: An object that inherits from :class:`View`.
	:param k_list cast: Optional cast list.
	:returns: TRUE if it **cannot** be where it is, FALSE otherwise.
	
	.. NOTE::
		This is used in the class system when the object moves.
		If it can't be where it is, it sets it to it's previous coordinates.
		If castList is specified, it checks the viewObj against the objects in the list
		to see if it can be where it is. 
 */
public bool CantBeHere(View view)
bool CantBeHere(View view, k_list castList)
{
}

/*
	Returns the height of a cel, specified by view, loop and cel.

	:param number view: View number.
	:param number loop: Loop number.
	:param number cel: Cel number.
	:returns: The height of the cel.
 */
public int CelHigh(int view, int loop, int cel)
{
}

/*
	Returns the width of a cel, specified by view, loop and cel.

	:param number view: View number.
	:param number loop: Loop number.
	:param number cel: Cel number.
	:returns: The width of the cel.
 */
public int CelWide(int view, int loop, int cel)
{
}

/*
	Checks if there would be enough space on the specified directory's disk to save the current game.
	
	:returns: TRUE if there is, FALSE if not.
 */
public bool CheckFreeSpace(string directory)
{
}

/*
	Checks to see if a particular saved game can be loaded.
	
	:param string gameName: The user-specified name of the game.
	:param number slotNumber: The game slot.
	:param string gameVerision: Optional parameter.
	:returns: TRUE on success, FALSE on fail.
	
	.. NOTE::
		This makes sure the saved game exists, is valid, and matches the gameName and gameVersion.
 */
public bool CheckSaveGame(string gameName, int slotNumber)
bool CheckSaveGame(string gameName, int slotNumber, string gameVersion)
{
}

/*
	Creates a new instance of a class or object and returns a pointer to it.

	:param heapPtr object: An object to clone.
	:returns: Pointer to a clone of the object.

	Example::

		Event newEvent;
		newEvent = Clone(Event); 	// create an instance of Event and stores the pointer into newEvent
		GetEvent($7FFF newEvent); 	// use the instance
		DisposeClone(Event) 		// dispose of the instance
 */
public Obj Clone(Obj object)
{
}

/*
	Returns the priority number at row y.
 */
public int CoordPri(int y)
{
}

/*
	Returns the factor divided by the cosine of angle * PI / 180.0.

	:param number angle: The angle.
	:param number factor: The factor by which to divide.
	
	See Also: :func:`CosMult`, :func:`SinDiv`, :func:`SinMult`
 */
public int CosDiv(int angle, int factor)
{
}

/*
	Returns the cosine of angle * PI / 180.0 multiplied by factor.

	:param number angle: The angle.
	:param number factor: The factor by which to multiply.
	
	See Also: :func:`CosDiv`, :func:`SinDiv`, :func:`SinMult`
 */
public int CosMult(int angle, int factor)
{
}

/*
	Finds the node with the specified key in list and deletes it.

	:param k_list list: A list.
	:param number key: A key associated with a node in the list.
	:returns: TRUE if the node was deleted.
	
	See also:
	:func:`AddToFront`, :func:`AddToEnd`, :func:`AddAfter`, :func:`FindKey`
 */
public bool DeleteKey(k_list list, int key)
{
}

/*
	Retrieves information about the computer's devices.

.. function:: DeviceInfo(diGET_DEVICE thePath outBuffer)

	Obtains the drive letter from a directory string.
	It evaluates the specified path and writes it's drive letter to strBuf.

	:param string thePath: A directory string.
	:param string buffer: A buffer in which to write the drive letter.
	:returns: a pointer to the end of the string written to outBuffer (the index of the NULL terminating character).
		
	Example::

		char strBuf[3];
		DeviceInfo(diGET_DEVICE "C:\scistudio" @strBuf)
		Print(@strBuf); // Prints "C:"
	
.. function:: DeviceInfo(diGET_CURRENT_DEVICE thePath outBuffer)

	Obtains the drive letter the current path and and writes it to strBuf.

	:param string thePath: A directory string.
	:param string buffer: A buffer in which to write the drive letter.
	:returns: a pointer to the end of the string written to outBuffer (the index of the NULL terminating character).
		
	Example::

		char strBuf[3];
		DeviceInfo(diGET_CURRENT_DEVICE @strBuf);
		Print(@strBuf); // Prints "C:", "D:", or whatever the current drive is

.. function:: DeviceInfo(diPATHS_EQUAL path1 path2)

	Compares path1 and path2. If they both point to the same physical location, it returns TRUE, otherwise, FALSE. 

	:param string path1: The first path.
	:param string path2: The second path.
	:returns: TRUE if both paths point to the same physical location.

	Example::

		char aPath[100];
		if (DeviceInfo(diPATHS_EQUAL @aPath "C:\scistudio"))
		{
			Print("The paths are equal");
		} 
	
.. function:: DeviceInfo(diIS_FLOPPY thePath)

	Checks the specified drive letter to see if it's a floppy or not, returning TRUE or FALSE.

	:param string thePath: A path with a drive letter.
	:returns: TRUE if the drive letter is a floppy drive.

	Example::

		DeviceInfo(diIS_FLOPPY "A:") // returns TRUE
		DeviceInfo(diIS_FLOPPY "C:") // returns FALSE

.. function:: DeviceInfo(command)

	It is unknown what this does.

	Example::

		DeviceInfo(4);
 */
public var DeviceInfo(int command, string thePath, string outBuffer)
bool DeviceInfo(int command, string thePath)
void DeviceInfo(int command)
void DeviceInfo(string outBuffer)
{
}

/*
	:param heapPtr view: The view object.
	:param number heading: The direction the view is facing.

	Sets the loop of the :class:`View` based on the heading angle provided.
	(i.e. if it's east, cel 0 is used).
 */
public void DirLoop(View view, int heading)
{
}

/*
.. function:: Display(text [params...])

	Displays the specified text to the screen.
	
	Following the text, you can specify how the string is displayed or handled with parameters.
	Each parameter has a type ID, specified in sci.sh.
	
	Allowed parameters:

	dsCOORD
		2 parameters: (x, y) coordinates at which to display the text.

	dsALIGN
		1 parameter: alRIGHT, alLEFT or alCENTER.

	dsCOLOUR
		1 parameter: set the colour.

	dsBACKGROUND
		1 parameter: set the background colour. -1 will use a transparent background.

	dsDISABLED
		1 parameter: set the disabled (grey) flag. 1 will draw disabled text.

	dsFONT
		1 parameter: the resource number of the font to use.

	dsWIDTH
		1 parameter: the width to wrap the text.

	dsSAVEPIXELS
		no parameters: set the "save under" flag to save a copy of the pixels before writing the text. The handle to the saved pixels is returned.

	dsRESTOREPIXELS
		1 parameter: handle to the saved pixels. With this command, the text and all the other parameters are ignored.

	Examples::

		Display("Hello World");

		Display(
			"Hello World"
			dsCOORD 60 80
			dsCOLOUR clRED
			dsBACKGROUND clYELLOW
			dsFONT 4
			dsALIGN alCENTER
			dsWIDTH 200
		); 

 */
public void Display(string text, ...)
{
}

/*
	Unloads an instance created by Clone() from memory.

	:param heapPtr object: The clone to dispose.
	
	See Also: :func:`Clone`
*/
public void DisposeClone(Obj object)
{
}

/*
	Disposes the list.

	:param k_list list: The list to dispose.
	
	See Also: :func:`NewList`
 */
public void DisposeList(k_list list)
{
}

/*
	Unloads a script from memory, including all it's classes, instances, variables, etc.

	:param number scriptNum: The script resource number.
 */
public void DisposeScript(int scriptNum)
{
}

/*
	Discards the specified window object and frees it from memory.

	:param k_window window: The window.
 */
public void DisposeWindow(k_window window)
{
}

/*
	Updates an avoider that is attached to an Actor. Sets the avoider's direction according to the angle and checks its onControl() method.
	
	.. IMPORTANT:: SCI0 only.

	:param heapPtr avoider: An instance of an :class:`Avoider`.
 */
public void DoAvoider(Avoider avoider)
{
}

/*
	Moves the object linked to the moverObj along the path generated by :func:`InitBresen`.

	:param heapPtr mover: A :class:`Motion` object attached to an :class:`Actor`.
	:returns: TRUE if the move was successful, FALSE if there was a collision.
	
	See Also: :func:`InitBresen`
 */
public bool DoBresen(Motion mover)
{
}

/*
	Do sound handles all sound related functions such as playing, loading, unloading, stopping, pausing, etc. It uses the first parameter to identify its subfunction, and the following parameters vary.

.. function:: DoSound(sndINIT soundObj)

	Sets up the specified sound object. It loads the sound resource specified by the sound object's number property and sets it's status property to ssINITIALIZED.

	:param heapPtr soundObj: An instance of :class:`Sound`.

	Example::

		DoSound(sndINIT soundObj)

.. function:: DoSound(sndPLAY soundObj)

	Plays the sound specified by the given sound object and sets the object's status property to sndPLAYING.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndDISPOSE soundObj)

	Disposes of the sound specified by the given object unloading it and removing it from the sound system.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndSET_SOUND [fTurnOn])

	Determines if the sound system is muted or not, and optionally mutes or unmutes it.

	:param boolean fTurnOn: Optional parameter to unmuted or mute the sound. If TRUE, the sound system is unmuted.
	:returns: TRUE if the sound system is unmuted, FALSE otherwise.

	Example::

		// If the sound system is not muted, mute it.
		(if(DoSound(sndSET_SOUND))
		  DoSound(sndSET_SOUND FALSE)
		)

.. function:: DoSound(sndSTOP soundObj)

	Stops playing the sound specified by the given sound object and sets the object's status property to sndSTOPPED.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndPAUSE soundObj)

	Pauses the sound specified by the given sound object and sets the object's status property to ssPAUSED.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndRESUME)

	.. IMPORTANT:: SCI0 only.

	Resumes playing sounds after a game has been resotred.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndVOLUME [volume])		**SCI0**

.. function:: DoSound(sndMASTER_VOLUME [volume])		**SCI1.1**

	Returns the currently set master sound volume, which is a number ranging from 0 to 15. Optionally sets the master volume.

	:param number volume: Optional new volume to set it to.
	:returns: The current volume.

.. function:: DoSound(sndUPDATE soundObj)

	Tells the sound system to update the specified sound. It notifies it that the sound has changed so its priority and loop properties are re-evaluated.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndFADE soundObj)   SCI0

	.. IMPORTANT:: SCI0 only.

	Fades the specified sound for roughly two seconds, then stops it, setting it's status property to ssSTOPPED.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndFADE soundObj targetVolume fadeTicker fadeStep stopAfterFade)   SCI1.1

	.. IMPORTANT:: SCI1.1 only.

	Fades the sound. This provides more options than the SCI0 version.

	:param heapPtr soundObj: An instance of :class:`Sound`.
	:param number targetVolume: The target volume, ranging from 0 - 127.
	:param number fadeTicker: Unknown (25 is a common value to specify).
	:param number fadeStep: The volume increment to fade each game cycle (10 is a common value).
	:param boolean stopAfterFade: If TRUE, the sound is stopped after the fade is complete.


.. function:: DoSound(sndCHECK_DRIVER)

	.. IMPORTANT:: SCI0 only.

	Checks to see if the sound driver is installed. If it is, it returns TRUE, otherwise, it returns FALSE.

	Example::

		(if( not DoSound(sndCHECK_DRIVER) )
			 Print("The sound driver is not installed!")
		)

.. function:: DoSound(sndSTOP_ALL)

	.. IMPORTANT:: SCI0 only.

	Stops all the sounds currently playing.

.. function:: DoSound(sndGET_POLYPHONY)

	.. IMPORTANT:: SCI1.1 only.

	:returns: The number of voices the sound hardware is capable of playing.

.. function:: DoSound(sndGET_AUDIO_CAPABILITY)

	.. IMPORTANT:: SCI1.1 only.

	Determines digital audio support.

	:returns: TRUE if digital audio support is available, otherwise FALSE.

.. function:: DoSound(sndSUSPEND)

	.. IMPORTANT:: SCI1.1 only.

	Unkonwn functionality. Not used in any Sierra games?

.. function:: DoSound(sndSET_HOLD soundObj marker)

	.. IMPORTANT:: SCI1.1 only.

	Sets the hold spot where the sound should be looped at. This is commonly used
	for engine sounds that want to loop at different spots for different pitches as
	the engine is starting and stopping.

	:param heapPtr soundObj: An instance of :class:`Sound`.
	:param number marker: Index of a hold marker in the Sound resource.

	.. NOTE:: SCI Companion doesn't currently support editing the hold markers in a sound resource.

.. function:: DoSound(UPDATE_CUES soundObj)

	.. IMPORTANT:: SCI1.1 only.

	Updates the sound.

	:param heapPtr soundObj: An instance of :class:`Sound`.

.. function:: DoSound(sndSEND_MIDI soundObj channel command controller parameter)

	.. IMPORTANT:: SCI1.1 only.

	Sends MIDI information to the sound resource.

	:param heapPtr soundObj: An instance of :class:`Sound`.
	:param number channel: The MIDI channel (e.g. 0-15).
	:param number command: The MIDI command.
	:param number controller: The MIDI controller.
	:param number parameter: A parameter for the command.

.. function:: DoSound(sndGLOBAL_REVERB reverb)

	.. IMPORTANT:: SCI1.1 only.

	:param number reverb: A reverb level (0 - 10).
	:returns: The previous reverb level.

*/
public var DoSound(int subFunction, ...)
{
}

/*
	This draws the specified cel at the specified position with the specified priority.
	
	The priority specifies if the view is drawn in front of or behind other objects.
 */
public void DrawCel(int view, int loop, int cel, int x, int y, int priority)
{
}

/*
	Draws the specified control object to the screen.
	Its properties tell where it should go and how it should behave.

	:param heapPtr control: An object that inherits from :class:`Control`.
	
	See Also: :func:`HiliteControl`, :func:`EditControl`
 */
public void DrawControl(Control control)
{
}

/*
	Draws or hides the menubar. If mode is TRUE, the menubar is drawn, otherwise it is made invisible.
	
	See Also: :func:`DrawStatus`
 */
public void DrawMenuBar(bool mode)
{
}


/*
	Draws a picture on the screen. The last three parameters are optional.
	If specified, they can define how the picture is displayed.
	If unspecified, the last used (or default) parameters are used.

	:param number picNum: The number of the pic resource that should be drawn.
	:param number animation: A value indicating the type of animation. See below.
	:param boolean clear: (dpCLEAR or dpNOCLEAR) If dpCLEAR, the screen will be cleared before drawing the picture. 
	:param number defaultPalette: **SCI0 only**. specifies the default palette to be used for drawing it (0-3). The palettes are contained in the pic files and can be edited with SCI Studio's picture editor. This is useful for displaying your picture in day/night colours.

	==========================  ============================================================
	SCI0
	----------------------------------------------------------------------------------------
	Flag                        Description
	==========================  ============================================================
	dpOPEN_INSTANTLY            display instantly
	dpOPEN_HCENTER              horizontally open from center
	dpOPEN_VCENTER              vertically open from center
	dpOPEN_RIGHT                open from right
	dpOPEN_LEFT                 open from left
	dpOPEN_BOTTOM               open from bottom
	dpOPEN_TOP                  open from top
	dpOPEN_EDGECENTER           open from edges to center
	dpOPEN_CENTEREDGE           open from center to edges
	dpOPEN_CHECKBOARD           open random checkerboard
	dpCLOSEREOPEN_HCENTER       horizontally close to center, reopen from center
	dpCLOSEREOPEN_VCENTER       vertically close to center, reopen from center 
	dpCLOSEREOPEN_RIGHT         close to right, reopen from right 
	dpCLOSEREOPEN_LEFT          close to left, reopen from left 
	dpCLOSEREOPEN_BOTTOM        close to bottom, reopen from bottom
	dpCLOSEREOPEN_TOP           close to top, reopen from top 
	dpCLOSEREOPEN_EDGECENTER    close from center to edges, reopen from edges to center 
	dpCLOSEREOPEN_CENTEREDGE    close from edges to center, reopen from center to edges
	dpCLOSEREOPEN_CHECKBOARD    close random checkboard, reopen 
	==========================  ============================================================	

	In SCI1.1, it can be set to one of the following values:

	==========================  ============================================================
	SCI1.1
	----------------------------------------------------------------------------------------
	Flag                        Description
	==========================  ============================================================
	dpOPEN_INSTANTLY            display instantly
	dpOPEN_HCENTER              horizontally open from center
	dpOPEN_VCENTER              vertically open from center
	dpOPEN_RIGHT                open from right
	dpOPEN_LEFT                 open from left
	dpOPEN_BOTTOM               open from bottom
	dpOPEN_TOP                  open from top
	dpOPEN_EDGECENTER           open from edges to center
	dpOPEN_CENTEREDGE           open from center to edges
	dpOPEN_CHECKBOARD           open random checkerboard
	dpOPEN_PIXELATION           pixelated transition
	dpOPEN_FADEPALETTE          fade the palette to black
	dpOPEN_SCROLL_RIGHT         scroll to the right
	dpOPEN_SCROLL_LEFT          scroll to the left
	dpOPEN_SCROLL_UP            scroll up
	dpOPEN_SCROLL_DOWN          scroll down
	dpOPEN_NO_TRANSITION        straight cut.
	dpANIMATION_BLACKOUT        add this flag when transitioning between different palettes
	==========================  ============================================================	

	Since in SCI1.1, each room might be using a different palette, it can be useful to completely transition off
	the previous screen before transitioning to the new screen. This is what dpANIMATION_BLACKOUT is used for.

	Example::

		DrawPic(100 dpCLOSEREOPEN_EDGECENTER dpCLEAR)
 */
public void DrawPic(int picNum [, int animation, bool clear, int defaultPalette])
{
}

/*
	Draws the specified text on the status bar.

	Example::

		DrawStatus(" Score 0 of 100                   Awesome Quest ");
 */
public void DrawStatus(string text)
{
}

/*
	By specifying an edit control object and an event object,
	it will handle everything related to the edit control,
	such as letting the user enter text.
	 
	The event object is then updated accordingly.

	:param heapPtr control: An object that inherits from :class:`DEdit`.
	:param heapPtr event: An :class:`Event` object.
	
	See Also: :func:`DrawControl`, :func:`HiliteControl`
 */
public void EditControl(Control control, Event event)
{
}

/*
    :param k_list pList: A list.
    :returns: TRUE if pList is empty.
*/
public bool EmptyList(k_list pList)
{
}

/*
	Closes a file.

	.. IMPORTANT::
		This kernel is SCI0 only. For SCI1.1, see :func:`FileIO`.

	:param number handle: A file handle.

	See also: :func:`FOpen`, :func:`FGets`, :func:`FPuts`.
*/
public void FClose(int handle)
{
}

/*
	Reads a string from the file pointed to by handle and stores it in buffer. If the string's length is greater than max, only max bytes are read.

	.. IMPORTANT::
		This kernel is SCI0 only. For SCI1.1, see :func:`FileIO`.

	:param string buffer: A buffer where the string is written.
	:param number max: The maximum number of bytes to read.
	:param number handle: A file handle.
	:returns: The number of bytes read.

	See also: :func:`FOpen`, :func:`FClose`, :func:`FPuts`.
*/
public int FGets(string buffer, int max [, int handle])
{
}

/*
	Finds the node with the specified key in list and returns it.

	:param k_list list: A list.
	:param number key: A key associated with a node.
	:returns: The node with the specified key, or NULL if it can not be found.
	
	See also: :func:`AddToFront`, :func:`AddToEnd`, :func:`AddAfter`, :func:`DeleteKey`.
 */
public k_node FindKey(k_list list, int key)
{
}

/*
	Returns the first node in the list.

	:param k_list pList: The list.
	:returns: The first node in the list.
*/
public k_node FirstNode(k_list pList)
{
}

/*
	Flushes the game's resources.

	:param number scriptNumber: The room we are about to enter.
*/
public void FlushResources(int scriptNumber)
{
}

/*
	Opens the file with the specified mode. Upon success, it returns a handle to the file, otherwise, it returns NULL.

	.. IMPORTANT::
		This kernel is SCI0 only. For SCI1.1, see :func:`FileIO`.

	:param string name: The filename.
	:param number mode: The open mode.

	The modes are as follows:

	============= =======================================================================
	Mode          Description
	============= =======================================================================
	fOPENCREATE   open or fail: Try to open file, abort if not possible
	fOPENFAIL     open or create: Try to open file, create it if it doesn't exist
	fCREATE       create: Create the file, destroying any content it might have had
	============= =======================================================================

	.. NOTE::
		You may note that the mode flags don't match the descriptions. SCI Studio had the flags defined incorrectly, and this reflects that error. This is not the case for :func:`FileIO`.

	Example::

		(var hFile, buffer[41])
		// Open the file and write to it
		(if( <> NULL (= hFile FOpen("somefile.txt" fCREATE)) )
			FPuts(hFile "Hello World!")
			FClose(hFile)
		)

		// Open the file, read it's first string, and print it to the screen
		(if( <> NULL (= hFile FOpen("somefile.txt" fOPENFAIL)) )
			FGets(buffer 40 hFile)
			FClose(hFile)

			Print(buffer)
		)
*/
public int FOpen(string filename)
int FOpen(string filename, int mode)
{
}

/*
	Formats the fmtString with the given parameters and stores it in destString. It then returns a pointer to the destString.

	:param string destString: The buffer to which the string will be written.
	:param string formatString: The formatting string.
	:param number resourceNumber: A text resource number.
	:param number textId: An index in the text resource to use for the formatting string.

	There are a number of different formatting options available::

		// The following are for numbers:
		Format(aString "Number: %d" 5) // Would print "Number: 5"
		Format(aString "Number: %03d" 5) // Would print "Number: 005"
		Format(aString "Number: %3d" 5) // Would print "Number:   5"
		Format(aString "Number: %-3d" 5) // Would print "Number: 5  "
		// The following are for unsigned numbers:
		Format(aString "Number: %u" 5) // Would print "Number: 5"
		Format(aString "Number: %03u" 5) // Would print "Number: 005"
		Format(aString "Number: %3u" 5) // Would print "Number:   5"
		Format(aString "Number: %-3u" 5) // Would print "Number: 5  "
		// The following are for hex:
		Format(aString "Number: %x" $A5) // Would print "Number: A5"
		Format(aString "Number: %03x" $A5) // Would print "Number: 0A5"
		Format(aString "Number: %3x" $A5) // Would print "Number:  A5"
		Format(aString "Number: %-3x" $A5) // Would print "Number: A5 "
		// The following are for strings:
		Format(aString "String: %s" "Hello") // Would print "String: hello"
		Format(aString "String: %10s" "Hello") // Would print "String:      Hello"
		Format(aString "String: %-10s" "Hello") // Would print "String: Hello    "
*/
public string Format(string destString, string formatString, ...)
string Format(string destString, uint resourceNumber, uint textId, ...)
{
}

/*
	Writes the string contained in buffer to the file pointed to by handle.

	.. IMPORTANT::
		This kernel is SCI0 only. For SCI1.1, see :func:`FileIO`.

	:param number handle: The file handle.
	:param string buffer: The string to write.

	See also: :func:`FOpen`, :func:`FGets`, :func:`FClose`.
*/
public void FPuts(int handle, string buffer)
{
}

/*
	:param boolean fRestarting: If FALSE, tells the engine that the game is not restarting.
	:returns: TRUE if the game is restarting.
*/
public bool GameIsRestarting([bool fRestarting])
{
}

/*
	Calculates the angle of the two points and returns it. It always generates a positive angle.

	:param number x1: The x coordinate of the first point.
	:param number y1: The y coordinate of the first point.
	:param number x2: The x coordinate of the second point.
	:param number y2: The y coordinate of the second point.

	Example::

		(var anAngle)
		// Get angle between (10, 20) and (100, 80)
		= anAngle GetAngle(10 20 100 80)
*/
public int GetAngle(int x1, int y1, int x2, int y2)
{
}

/*
	Retrieves current directory and stores it in buffer.

	:param string buffer: Buffer in which to write the current directory path.
	:returns: A pointer to buffer.
*/
public string GetCWD(string buffer)
{
}

/*
	Calculates the distance between the two points and returns it.

	:param number x1: The x coordinate of the first point.
	:param number y1: The y coordinate of the first point.
	:param number x2: The x coordinate of the second point.
	:param number y2: The y coordinate of the second point.
	:param number picAngle: Optional pic angle.
	:returns: The distance between the two points.

	Example::

		(var aDistance)
		= aDistance GetDistance(10 20 100 80)
*/
public int GetDistance(int x1, int y1, int x2, int y2 [, int picAngle])
{
}

/*
	GetEvent retrieves the event type(s) and places them in the specified event object's properties.
	See :class:`Event` for further description of the event types.

	:param number types: A bitmask of event types.
	:param heapPtr event: An :class:`Event` object.

	:returns: TRUE if the event was created, otherwise FALSE.
*/
public bool GetEvent(int types, Event event)
{
}

/*
	Reads a string from a text resource and copies it to buffer. It loads text resource resourceNum, and accesses the textId numbered string. It returns a pointer to buffer.

	:param number resourceNum: A text resource number.
	:param number textId: An id into the text resource.
	:param string buffer: The buffer that receives the string.
	:returns: A pointer to buffer.
*/
public string GetFarText(int resourceNum, int textId, string buffer)
{
}

/*
.. function:: GetMenu(menuItem subFunction [params...])

	Get a menu item's properties. Following the menuItem parameter, you can specify what property you would like to obtain with a subFunction parameter.

	:param number menuItem: A menu item identifier, e.g. $0302 for the second item in the third menu.
	:param number subFunction: One of smMENU_SAID, smMENU_TEXT, smMENU_SHORTCUTKEY, smMENU_ENABLE.

	Examples::

		(var theSaid, theKey)
		// Retrieve the said string for an item.
		= theSaid GetMenu($202 smMENU_SAID)

		// Get the menu item's text.
		Print(GetMenu($202 smMENU_TEXT))

		// Get the menu item's shortcut key.
		= theKey GetMenu($202 smMENU_SHORTCUTKEY)

		// Tell if a menu item is enabled.
		(if(SetMenu($202 smMENU_ENABLE))
		   Print("The item is enabled!")
		)
*/
public var GetMenu(int menuItem, int subFunction)
{
}

/*
.. function:: GetPort()

	Retrieves the currently active port and returns it.

	:returns: The currently active port.

	Example::

		(var hWnd, oldPort)
		= oldPort GetPort()
		// Draw a white window at 50, 20 with a width of 200 100, a title, and a black foreground.
		= hWnd NewWindow(
			50 20 250 120
			"Test Window"
			nwTITLE
			nwON_TOP
			clBLACK
			clWHITE
		)

		SetPort(hWnd)
		Display("Hello in the hWnd window!")
		SetPort(oldPort)
		Display("Hello in the oldPort!")
		DisposeWindow(hWnd)
*/
public k_window GetPort()
{
}

/*
	Retrieves a pointer to the string containing the save directory and returns it.

	:returns: A pointer to a string containing the save directory.

	Example::

		(var theString)
		= theString GetSaveDir()
		Print(theString)
*/
public string GetSaveDir()
{
}

/*
	Retrieves the total number of save files and their descriptions.
	The descriptions of the saved games are stored in the descBuffer. The slot numbers of the saved game strings' saved games are stored in the descSlots array.

	:param string gameName: The name of the game.
	:param string descBuffer: Buffer where descriptions of the games will be written.
	:returns: The number of saved games, or -1 if there was an error.
*/
public int GetSaveFiles(string gameName, string descBuffer, var descSlots)
{
}

/*
	Retrieves the current time. If fTIME_OF_DAY is specified, it returns the time of day in seconds.
	Otherwise, it returns the number of ticks elapsed since the game was started.

	:returns: The time of day in seconds or ticks.
*/
public int GetTime()
int GetTime(bool fTimeOfDay)
{
}

/*
	Converts the event object from a screen relative one to a port relative one. It will make the event only be true if it is occuring in the currently active port (window).

	:param heapPtr event: An :class:`Event` object.
*/
public void GlobalToLocal(Event event)
{
}

/*
.. function:: Graph(grGET_COLORS)
.. function:: Graph(grDRAW_LINE y1 x1 y2 x2 [visualColor priColor ctlColor])
.. function:: Graph(grSAVE_BOX y1 x1 y2 x2 [screen])
.. function:: Graph(grRESTORE_BOX handle)
.. function:: Graph(grFILL_BOX y1 x1 y2 x2 screens [visualColor priColor ctlColor])
.. function:: Graph(grFILL_BOX_BACKGROUND y1 x1 y2 x2)
.. function:: Graph(grFILL_BOX_FOREGROUND y1 x1 y2 x2)
.. function:: Graph(grUPDATE_BOX screen)
.. function:: Graph(grREDRAW_BOX y1 x1 y2 x2)
.. function:: Graph(grADJUST_PRIORITY min max)

	Graph is a kernel with many sub functions. It should be noted that the order of the coordinates
	(y, followed by x) is the opposite of most kernels.

	:param number y1: The top of the box.
	:param number x1: The left side of the box.
	:param number y2: The bottom of the box.
	:param number x2: The right side of the box.
	:param number screen: A screen (VISUAL, PRIORITY or CONTROL).
	:param number screens: A bitmask of VISUAL, PRIORITY or CONTROL.
	:param number handle: A handle returned by grSAVE_BOX.
	:param number visualColor: The color value for the visual screen.
	:param number priColor: A priority value, or -1 to indicate none specified.
	:param number ctlColor: A control color, or -1 to indicate none specified.
	:param number min: The minimum priority band.
	:param number max: The maximum priority band.
	:returns: Various values. See below.

	The following functions are available:

	grGET_COLORS
		Obtains the color resolution which the interpreter is running in. **Returns** the number of colors.

	grDRAW_LINE
		Draws a line on the specified screen(s) with the specified color.

	grSAVE_BOX
		Saves the screen pixels in the specified area and **returns** a handle to them. If screen is specified, it saves the pixels of that screen (VISUAL,PRIORITY,CONTROL). Otherwise, it uses the VISUAL screen.

	grRESTORE_BOX
		Restores the pixels saved with grSAVE_BOX.

	grFILL_BOX
		Fills the specified rectangular region with the specified color(s). The screens parameter specifies which screens to drawn to.

	grFILL_BOX_BACKGROUND
		Operates just like grFILL_BOX, but draws a box on the visual screen with the current port's background color.

	grFILL_BOX_FOREGROUND
		Operates just like grFILL_BOX, but draws a box on the visual screen with the current port's foreground color.

	grUPDATE_BOX
		Draws the specified area of the specified screen to the screen. You can use this to redraw the background picture, and also to view the priority/control screens. 

	grREDRAW_BOX
		Redraws the specified area of visual screen to the screen.

	grADJUST_PRIORITY
		Sets the minimum and maximum bounds for the priority. By default, these values are 42 and 190 in SCI0.

	Example for grGET_COLORS::

		(var colors) 
		= colors Graph(grGET_COLORS) 
		(if( == colors 16)
			Print("You are running in EGA mode")
		)(else
			(if( == colors -1)
				Print("You are running in CGA mode")
			) 
			(else
				// VGA returns 25 in the original interpreter, but 256 in ScummVM.
				Print("You are probably in VGA mode")
			)
		)

	Example for grUPDATE_BOX::

		// Shows the priority screen for two seconds
		Graph(grUPDATE_BOX 0 0 199 319 PRIORITY)
		Wait(120)

		// Shows the control screen for two seconds
		Graph(grUPDATE_BOX 0 0 199 319 CONTROL)
		Wait(120)

		// Shows the visual screen
		Graph(grUPDATE_BOX 0 0 199 319 VISUAL)

	Example for grFILL_BOX::

		// Draws a box with the bounds of (30,20) and (200,100) on the visual screen in yellow, the priority screen in red, and the control screen in blue.
		Graph(grDRAW_BOX 20 30 100 200 ALL_SCREENS clYELLOW clRED clBLUE)

		// Doesn't draw anything though the colors are specified, no screens are
		Graph(grDRAW_BOX 20 30 100 200 0 clYELLOW clRED clBLUE)

		// Draws a box with the bounds of (60,40) and (160,130) on the visual screen in white, and the control screen in brown.
		Graph(grDRAW_BOX 40 60 130 160 VISUAL_CONTROL clWHITE -1 clBROWN)

	Example for grRESTORE_BOX and grSAVE_BOX::

		// this saves the center of the screen, draws a line, then restores the area leaving only the line's edges
		(var handle)
		= handle Graph(grSAVE_BOX 50 80 150 240)
		Graph(grDRAW_LINE 10 10 180 310 clYELLOW) 
		Graph(grRESTORE_BOX handle)

	Example for grDRAW_LINE::

		// Draw a line from (30,20) to (200,100) on the visual screen in yellow, the priority screen in red, and the control screen in blue.
		Graph(grDRAW_LINE 20 30 100 200 clYELLOW clRED clBLUE)

		// Draw a line from (60,40) to (160,130) on the visual screen in white, and the control screen in brown.
		Graph(grDRAW_LINE 40 60 130 160 clWHITE -1 clBROWN)

		// Draw a line from (10,20) to (40,50) on the visual screen in red.
		Graph(grDRAW_LINE 20 10 50 40 clRED)

*/
public var Graph(int subFunction, ...)
{
}

/*
	:returns: TRUE if a mouse is present, FALSE otherwise. Squeak!
*/
public bool HaveMouse()
{
}

/*
	Highlights the specified control. It does not draw the control, it just inverts the colors. The control must be drawn first using :func:`DrawControl`.

	:param heapPtr control: A control of type :class:`Control`.

	See also: :func:`DrawControl`, :func:`EditControl`.
*/
public void HiliteControl(Control control)
{
}

/*
	Initializes the mover object for its movement to its x and y coordinates. It uses the Bresenham line algorithm to figure out how much to move each step resulting in a direct path from its client's coordinates to its x and y.

	:param heapPtr mover: An instance of a :class:`Motion` class.
	:param number stepMult: Optional multiplier.

	If stepMult is specified, it will move xStep \* stepMult and yStep \* stepMult.

	See also: :func:`DoBresen`.
*/
public void InitBresen(Motion mover [, int stepMult])
{
}

/*
	Part of the debugger, InspectObj executes the object inspector window for the specified object allowing you to view/set it's properties at runtime.

	.. IMPORTANT::
		This is only available in SCI0.
*/
public void InspectObj(Obj obj)
{
}

/*
	Determines whether a value is an object.

	:param obj: Something that might be an object.
	:returns: TRUE if obj is an object.

	Example::

		(var objPtr)
		= objPtr (Event:new())
		IsObject(objPtr) // returns TRUE
		= objPtr 0
		IsObject(objPtr) // returns FALSE
*/
public bool IsObject(var obj)
{
}

/*
	Calls the joystick driver with subfunction and state as it's parameters. If subfunction is not jsCALL_DRIVER, it doesn't do anything. It returns the previous state of the joystick.

	Example::

		(var menuItem, joyState)
		= joyState Joystick(jsCALL_DRIVER 30)
		= menuItem MenuSelect(pEvent)
		Joystick(jsCALL_DRIVER joyState)
*/
public int Joystick(int subFunction, int state)
{
}

/*
	Returns a pointer to the last node in the given list.

	:param k_list pList: A list.
	:returns: A pointer to the last node.

	See also: :func:`FirstNode`, :func:`PrevNode`, :func:`NextNode`.
*/
public k_node LastNode(k_list pList)
{
}

/*
	Loads a resource into memory. If the resource type is rsMEMORY, is will allocate resourceNumber bytes of memory. It returns a pointer to the resource loaded or memory allocated.

	:param number resourceType: rsVIEW, rsPIC, etc...
	:param number resourceNumber: The resource number, or the number of bytes to allocate in the case of rsMEMORY.
	:returns: A pointer to the memory in the case of rsMEMORY.

	See also: :func:`Unload`.

	Example::

		(var hView, memPtr)
		= hView Load(rsVIEW 100) // loads VIEW.100
		= memPtr Load(rsMEMORY 1024) // allocates 1024 bytes of memory
		UnLoad(rsVIEW 100) // unloads VIEW.000 from memory
		UnLoad(rsMEMORY memPtr) // frees memPtr from
*/
public var Load(int resourceType, int resourceNumber)
{
}

/*
	Converts the event object from a port relative one to a screen relative one. If the event is specific to window, it will make it available to the entire screen.

	:param heapPtr event: An :class:`Event` object.
*/
public void LocalToGlobal(Event event)
{
}

/*
	This converts a keyboard event to a movement event. For example, if they press the UP key, it will convert that to an UP movement event. It returns a ponter to the event object.

	:param heapPtr event: An :class:`Event` object.
	:returns: A pointer to the event.
*/
public Event MapKeyToDir(Event event)
{
}

/*
	Retreives and returns the specified type of memory information.

	:param number type: miFREEHEAP, miLARGESTPTR, miFREEHUNK or miLARGESTHUNK.
	:returns: The information requested.

	The type can be one of the following:

	==================== =======================================================================
	type                 Description
	==================== =======================================================================
	miFREEHEAP           The amount of free memory in the heap.
	miLARGESTPTR         The size of the largest chunk of heap memory.
	miFREEHUNK           The size of the largest available hunk memory block.
	miLARGESTHUNK        The total amount of free hunk memory, shifted to the right by 4 bits.
	==================== =======================================================================

	Example::

		FormatPrint(
			"Free Heap: %u Bytes\nLargest ptr: %u Bytes\nFreeHunk: %u KBytes\nLargest hunk: %u Bytes"
			MemoryInfo(miFREEHEAP)
			MemoryInfo(miLARGESTPTR)
			(>> MemoryInfo(miFREEHUNK) 6)
			MemoryInfo(miLARGESTHUNK)
		)
*/
public int MemoryInfo(int type)
{
}

/*
.. function:: MenuSelect(event [fPauseSound])

	Checks to see if the menu has been activated (either by clicking or pressing ESC).
	If it has, the user can select an item from the menu. If an item is selected, it returns the index of the item. If not, it returns -1.	

	:param heapPtr event: An :class:`Event` object.
	:param boolean fPauseSound: If TRUE or unspecified, the sound is paused.
	:returns: Index of the item selected, or -1 if none selected.
*/
public int MenuSelect(Event event, ...)
{
}

/*
	Creates an empty list and returns a pointer to it.

	:returns: A new list.

	See also: :func:`DisposeList`.
*/
public k_list NewList()
{
}

/*
	Creates a new node setting its value and key to the given parameters.
	The value is the value it contains, the key is the identifier used to find it in the list it's attatched to.

	:param value: A value to put in the new node.
	:param number key: A key for the new node.
	:returns: The new list node.
*/
public k_node NewNode(var value, int key)
{
}

/*
	Draws a new window on the screen with the specified properties and returns the structure's address.

	:param number x: Left side of the window.
	:param number y: Top of the window.
	:param number width: Width of the window.
	:param number height: Height of the window.
	:param number flags: Flags that specify how the window is to be drawn. See below.
	:param number priority: Specifies if the window should be drawn above or below other windows. The higher the priority, the more visible it will be. With a priority of zero, it may be completely covered by other windows. To make sure your window is visible, you can use nwON_TOP as the priority.
	:param number foreColor: Specifies the foreground color for the window. It is used for text, buttons, etc...
	:param number backColor: Specifies the background color for the window.

	Window flags:
	
	========================= ==================================================================
	Flag                      Description
	========================= ==================================================================
	nwNORMAL                  The window will be drawn with a border.
	nwTRANSPARENT             The window will not have a border, background color, or titlebar.
	nwNOFRAME                 The window will be drawn without a border.
	nwTRANSPARENT_NOFRAME     The window will be drawn without a border and a transparent body.
	nwTITLE                   The window will be drawn with a titlebar and border.
	nwNODRAW                  The window will not be drawn.
	========================= ==================================================================

	Example::

		(var hWnd, oldPort)
		= oldPort GetPort()
		// Draw a white window at 50, 20 with a width of 200 100, a title, and a black foreground.
		= hWnd NewWindow(
			50 20 250 120
			"Test Window"
			nwTITLE
			nwON_TOP
			clBLACK
			clWHITE
		)

		SetPort(hWnd)
		Display("Hello in the hWnd window!")
		SetPort(oldPort)
		Display("Hello in the oldPort!")
		DisposeWindow(hWnd)
*/
public k_window NewWindow(int x, int y, int width, int height, string title, int flags, int priority, int forecolor, int backcolor)
{
}

/*
	Returns a pointer to the node after the given node in a list. It returns NULL is there isn't one.

	:param k_node pNode: The list node.
	:returns: A pointer to the next node.

	See also: :func:`PrevNode`.
*/
public k_node NextNode(k_node pNode)
{
}

/*
	Returns a the value of the specified node.

	:param k_node pNode: The list node.
	:returns: The value of the node.
*/
public var NodeValue(k_node node)
{
}

/*
	By specifying a instance or class as the parameter, it looks up the view and loop properties and
	returns the total number of cels in that loop. If the view is not loaded, it will automatically load it.

	:param heapPtr view: An instance or class of :class:`View`.
	:param heapPtr icon: An instance or class of :class:`DIcon`.
	:returns: The total number of cels in the current loop of the View or icon.
 */
public int NumCels(View view)
int NumCels(DIcon icon)
{
}

/*
	By specifying a instance or class as the parameter, it looks up the view property and returns the total number of loops in the view. If the view is not loaded, it will automatically load it.

	:param heapPtr view: An instance or class of :class:`View`.
	:returns: The number of loops in the current view of the View.
*/
public int NumLoops(View view)
{
}

/*
	Checks to see which colors are at the specified coords or in the rect. It checks the specified map and returns a 16 bit color map.

	:param number map: ocVISUAL, ocPRIORITY or ocSPECIAL (ocSPECIAL is the control information).
	:param number x: The x coordinate.
	:param number y: The y coordinate.
	:param number left: Left side of the rectangle.
	:param number top: Top of the rectangle.
	:param number width: Width of the rectangle.
	:param number height: Height of the rectangle.

	Example::

		// Using a point
		(if (== ctlRED OnControl(ocSPECIAL 120 90)
			Print("It is on a red control line!")
		)

		// Using a rect, multiple colors may be returned, so you should use the & operator.
		(if (& ctlBLUE OnControl(ocSPECIAL 50 20 100 40)
			Print("It is on a blue control line!")
		)

*/
public int OnControl(int map, int x, int y)
int OnControl(int map, int left, int top, int width, int height)
{
}

/*
	Parses the specified text and creates a parse event, returning it in the event object specified. It returns TRUE if the text is successfully parsed, otherwise, FALSE.

	.. IMPORTANT:: This is SCI0 only.

	:param string text: The text to parse (generally input by the player).
	:param heapPtr event: An :class:`Event` object.
	:returns: TRUE if the text is successfully parsed.

	Example::

		(var hEvent)
		= hEvent (Event:new())
		(if (Parse("open door" hEvent))
			(if(Said('open/door')
				Display("The door is now open")
			)
		)
*/
public bool Parse(string text, Event event)
{
}

/*
	If specified, it sets the game's picNotValid flag to newFlag. The picNotValid flag is used by other functions to determine whether or not the background picture is considered valid.

	:param number newFlag: The value to set the game's picNotValid flag to.
	:returns: The previous picNotValid flags.

	See also: :func:`Show`.
*/
public int PicNotValid([int newFlag])
{
}

/*
	Returns a pointer to the node before the given node in a list. It returns NULL is there isn't one.

	:param k_node pNode: The list node.
	:returns: A pointer to the previous node.

	See also: :func:`NextNode`.
*/
public k_node PrevNode(k_node node)
{
}

/*
	Profiler is a member of the debugging system. It is disabled in Sierra's public interpreter releases.

	See also: :func:`InspectObj`, :func:`ShowSends`, :func:`ShowObjs`, :func:`ShowFree`, :func:`StackUsage`, :func:`MemoryInfo`.
*/
public void Profiler()
{
}

/*
	Generates a random number between min and max and returns it.

	:param number min: Inclusive lower bound.
	:param number max: Inclusive upper bound.
	:returns: The random number.

	Example::

		(var aRandomNumber)
		= aRandomNumber Random(1 10) // Generates a random number between 1 and 10
*/
public int Random(int min, int max)
{
}

/*
	Reads the given string and converts it to a number. It can convert hex strings as long as they begin with $. It returns the number generated.

	:param string text: The text with a number in it.
	:returns: The number extracted from the text.

	Example::

		(var aNumber)
		= aNumber ReadNumber("500")
		= aNumber ReadNumber("$12AB")
*/
public int ReadNumber(string text)
{
}

/*
	Checks to see if the object will respond to the specified selector (property or method).
	Call this before calling an object's method or accessing an object's property if you are unsure if the object actually contains it.

	:param heapPtr obj: The object.
	:param selector aSelector: The method or property selector.
	:returns: TRUE if the object does respond to the selector, otherwise, FALSE.

	Example::

		(if(RespondsTo(someObject #doit))
			(send someObject:doit())
		)
		(if(RespondsTo(someObject #text))
			(send someObject:text("Hello world!"))
		)
*/
public bool RespondsTo(Obj obj, selector aSelector)
{
}

/*
	Restarts the game. In the sense that the interpreter was an actual computer, this would be like pressing the reset button.
	It restarts the game by stopping all the sounds, disposing of the menubar, clearing the heap status, and disposing of all the scripts.
	Then, it starts executing the game again. Because of all of this, it doesn't return a value.

	See also: :func:`GameIsRestarting`, :func:`SaveGame`, :func:`RestoreGame`.
*/
public void RestartGame()
{
}

/*
	Restores a game state with the game saved in the specified slot number. The gameName and gameVersion parameters are used to prevent opening of games from other versions.

	:param string gameName: The name of the game.
	:param number slotNumber: The slot number of the save game.
	:param string gameVersion: The game version.

	Example::

		RestoreGame("LSL3" 2 "1.002")
*/
public void RestoreGame(string gameName, int slotNumber, string gameVerison)
{
}



/*
	Checks to see if the specified string matches the last line parsed.
	
	
	:param saidString saidString: The string to match.
	:returns: TRUE if there was a match, otherwise FALSE.

	The following operators can be used in a said string:

	,
		"OR", Used to specify alternatives to words, such as "take,get".

	/
		Sentence part separator.  Only two of these tokens may be used, since sentences are split into a maximum of three parts.

	(
		Used together with ')' for grouping.

	)
		See '('.

	[
		Used together with ']' for optional grouping. "[a]" means "either a or nothing".

	]
		See '['.

	<
		Semantic reference operator (as in 'get<up')

	>
		Instructs Said() not to claim the event passed to the previous Parse() call on a match.  Used for successive matching.

	If a match is made, the words are "used up" until a fresh parse event happens. For example::
	
		if (Said('look'))
		{
		}
		if (Said('look')) // This will return FALSE, even if the previous line returned TRUE.
		{
			// We can never get here.
		}

	Other examples::

		Said('look/car')         // Matches "look car", "look in car"
		Said('look<in/car')      // Matches "look in car" only
		Said('give/food/dog')    // Matches "give food to dog" and "give dog food"
 */
public bool Said(said_string saidString)
{
}

/*
	Saves a game state to disk. It saves it in the slot number specified with the given description. The gameName and gameVersion parameters are used to prevent opening of games from other versions.

	:param string gameName: The name of the game.
	:param number slotNumber: The slot number of the save game.
	:param string gameVersion: The game version.
	:returns: TRUE on success, FALSE on failure.

	Example::

		SaveGame("LSL3" 2 "Some game saved in slot 2" "1.002")
*/
public bool SaveGame(string gameName, int slotNumber, string description, string gameVersion)
{
}

/*
	Returns the address in memory pointed to by entry Index in the exports segment of SCRIPT.<scriptNum>.

	Example::

		(var heapPointer)
		// gets the address in memory pointed to by entry 4 in the exports segment of SCRIPT.100.
		= heapPointer ScriptID(100 4) 
*/
public var ScriptID(int scriptNum [, int index])
{
}

/*
.. function:: SetCursor(resourceNumber [visible x y])

	.. IMPORTANT:: SCI0 only (See below for the SCI1.1 functions)

	Changes the mouse cursor, or shows and hides it.
	
	:param number resourceNumber: Number of the cursor resource to use.
	:param boolean visible: If TRUE or unspecifed, the cursor is shown.  Otherwise, it is hidden.
	:param number x: The x position at which to place the cursor.
	:param number y: The y position at which to place the cursor.

.. function:: SetCursor(command)

	.. IMPORTANT:: SCI1.1 only

	:param number command: A command indicating what do do.

	Cursor commands:

	========= ===============================
	Command   Description
	========= ===============================
	0         Hide cursor.
	-1        Clear zoom zone.
	-2        Reset zoom zone.
	any other Show cursor.
	========= ===============================

.. function:: SetCursor(x y)

	.. IMPORTANT:: SCI1.1 only

	Sets the position of the cursor.

	:param number x: The x position at which to place the cursor.
	:param number y: The y position at which to place the cursor.


.. function:: SetCursor(left top right bottom)

	Sets the move zone of the cursor.

	.. IMPORTANT::
		SCI1.1

	:param number left: The left side of the move zone.
	:param number top: The top of the  move zone.
	:param number right: The right side of the  move zone.
	:param number bottom: The bottom of the  move zone.

	Changes the mouse cursor, or shows and hides it.

.. function:: SetCursor(view loop cel [hotX hotY])

	Sets the view, loop and cel of the cursor, and optionally the hot spot.

	.. IMPORTANT::
		SCI1.1

	:param number view: View number.
	:param number loop: Loop number.
	:param number cel: Cel number.
	:param number hotX: The hotspot x coordinate.
	:param number hotY: The hotspot y coordinate.
 */
public void SetCursor(int resourceNumber [, bool visible, int x, int y])
{
}

/*
	Halts the game execution and starts the game debugger.
	From there, you can step through the execution of your game and inspect memory.

	.. IMPORTANT::
		This is SCI0 only.
	
	Type '?' in the debugger to see the list of commands.
	
	See Also:
	:func:`StackUsage`, :func:`InspectObj`, :func:`ShowObjs`, :func:`ShowFree`, :func:`ShowSends`, :func:`MemoryInfo`.
 */
public void SetDebug()
{
}

/*
	Sets up the jump mover object's xStep and yStep properties.

	:param heapPtr mover: An instance of :class:`Jump`.
 */
public void SetJump(Motion mover, int dx, int dy, int gy)
{
}

/*
.. function:: SetMenu(menuItem subFunction [params...])

	Sets a menu item's properties. Following the menuItem, you can specify how you want to modify the item with parameters. Each parameter has a type ID, specified in SCI.SH.

	:param number menuItem: A menu item identifier, e.g. $0302 for the second item in the third menu.
	:param number subFunction: One of smMENU_SAID, smMENU_TEXT, smMENU_SHORTCUTKEY, smMENU_ENABLE.

	Examples::

		// If the said string is said, the item's handleEvent() is called.
		SetMenu($202 smMENU_SAID 'save[/game]')

		// It sets the menu item's text to the given string.
		SetMenu($202 smMENU_TEXT "Save a Game")

		// Sets the menu item's shortcut key to the specified parameter. See KEYS.SH for the keycodes.
		SetMenu($202 smMENU_SHORTCUTKEY KEY_F5)

		// If the parameter is TRUE, it enables the menu item. Otherwise, it disables it.
		SetMenu($202 smMENU_ENABLE FALSE)

	See also: :func:`GetMenu`, :func:`AddMenu`.
*/
public
void SetMenu(int menuItem, int subFunction, string menuItemText)
void SetMenu(int menuItem, selector subFunction, string menuItemText)
void SetMenu(int menuItem, int subFunction, said_string menuItemSaid)
void SetMenu(int menuItem, int subFunction, int key)
void SetMenu(int menuItem, int subFunction, bool enable)
{
}

/*
	Makes the view visible on the screen.

	:param heapPtr view: An object derived from :class:`View`.

	It looks up the view object's x and y properties,
	as well as the view/cel/loop to determine it's width and height,
	then sets it's nsLeft, nsTop, nsRight and nsBottom properties accordingly. 
 */
public void SetNowSeen(View view)
{
}

/*
	Sets the current port to the specified one.
 */
public void SetPort(k_window newPort)
{
}

/*
	Examines the scripts pointed to by the objects in the specified set (by their script property).
	If they have any synonyms, it enables them.

	.. IMPORTANT::
		SCI0 only.
	
	This is handled automatically by the :func:`Rm` and :func:`Rgn` classes.

	Example::

		(synonyms
		  'grab' = 'open'
		)
		...

		SetSynonyms(gRegions) // the global variable pointing to the list of rooms
 */
public void SetSynonyms(Set scripts)
{
}

/*
	Shakes the screen a number of times.

	:param number shakeCount: The number of times to shake the screen.
	:param number direction: The direction in which to shake. If not specified, it shakes from left to right.
	
	================ =======================
	Direction        Description
	================ =======================
	ssLEFTRIGHT      Shakes from left to right.
	ssUPDOWN         Shakes up and down.
	ssFULL_SHAKE     Shakes the screen diagonally from the top left corner to the bottom right.
	================ =======================
	
	Example::

		ShakeScreen(8);				// Does a left to right shake screen eight times
		ShakeScreen(20 ssFULL_SHAKE); // Does a complete shake screen twenty times

 */
public void ShakeScreen(int shakeCount [, int direction])
{
}

/*
	Shows the visual, priority or control screen.

	:param number screen: VISUAL, PRIORITY or CONTROL.	
	
	This can be useful for debugging your game.
	
	Sets bit 1 of the picNotValid flag, making the picture "showable".
	The picNotValid flag is used by other functions to determine whether or not the background picture is considered valid.	
 */
public void Show(int screen)
{
}

/*
	Shows a debug window showing the amount of free heap. Part of the Sierra debugger.

	.. IMPORTANT::
		SCI0 only.

	See Also: :func:`StackUsage`, :func:`SetDebug`, :func:`InspectObj`, :func:`ShowSends`, :func:`ShowObjs`, :func:`MemoryInfo`
 */
public void ShowFree()
{
}

/*
	Shows a debug window showing all of classes and instances currently in memory. Part of the Sierra debugger.

	.. IMPORTANT::
		SCI0 only.

	See Also: :func:`StackUsage`, :func:`SetDebug`, :func:`InspectObj`, :func:`ShowSends`, :func:`ShowFree`, :func:`MemoryInfo`
 */
public void ShowObjs()
{
}

/*
	Shows a debug window showing all of the methods which have been called by send, but not yet finished. Part of the Sierra debugger.

	.. IMPORTANT::
		SCI0 only.

	See Also: :func:`StackUsage`, :func:`SetDebug`, :func:`InspectObj`, :func:`ShowObjs`, :func:`ShowFree`, :func:`MemoryInfo`
 */
public void ShowSends()
{
}

/*
	Returns the factor divided by the sine of angle * PI / 180.0.

	See Also: :func:`CosDiv`, :func:`CosMult`, :func:`SinMult`
 */
public int SinDiv(int angle, int factor)
{
}

/*
	Returns the sine of angle * PI / 180.0 multiplied by factor.

	See Also: :func:`CosDiv`, :func:`CosMult`, :func:`SinDiv`
 */
public int SinMult(int angle, int factor)
{
}

/*
	Calculates the square root of the given number and returns it.
 */
public int Sqrt(int value)
{
}

/*
	Returns the amount of current stack usage.
	
	See Also: :func:`SetDebug`, :func:`InspectObj`, :func:`ShowSends`, :func:`ShowObjs`, :func:`ShowFree`, :func:`MemoryInfo`
 */
public int StackUsage()
{
}

/*
.. function:: StrAt(aString index [replacement])

	StrAt has two functions. It can be used to retreive the char at the specified index in aString,
	or it can be used to set the character to replacement at the specified index in aString. It returns the character at aString[index].

	:param string aString: The text string.
	:param number index: The index into the text string.
	:param number replacement: The optional character place at that index.
	:returns: The character at the index specified.
*/
public char StrAt(string aString, int index)
char StrAt(string aString, int index, char replacement)
{
}

/*
	Appends src to dest and returns a pointer to dest.

	Example::

		(var aString[40], strPtr)
		StrCpy(aString "Hello World")
		StrCat(aString ", How Are You?") // aString will be "Hello World, How Are You?"
*/
public string StrCat(string dest, string src)
{
}

/*
.. function:: StrCmp(aString bString [max])

	Compares aString to bString. If max is specified, only max number of characters are compared.

	:param string aString: Text string A.
	:param string bString: Text string B.
	:param number max: The maximum number of chars to compare.
	:returns: STRINGS_EQUAL if the strings are equal. STRING_LESSTHAN if aString is less than bString. STRING_GREATER if aString is greater than bString.

	Example::

		(var aString[40], strPtr)
		StrCpy(aString "Hello World")
		(if( == STRINGS_EQUAL StrCmp(aString "Hello World"))
			Print("The string says Hello World")
		)
*/
public int StrCmp(string a, string b)
int StrCmp(string a, string b, int maxChars)
{
}

/*
.. function:: StrCpy(destString srcString [max])

	Copies destString to srcString. If max is specified, only max number of characters are copied. It returns a pointer to the destString.

	:param string destString: The destination string buffer.
	:param string srcString: The source string.
	:param number max: The maximum number of chars to copy.
	:returns: A pointer to destString.

	Example::

		(var aString[40], strPtr)
		StrCpy(aString "Hello World")
*/
public string StrCpy(string dest, string src)
string StrCpy(string dest, string src, int maxChars)
{
}

/*
	Returns a pointer to the end of the string.

	:param string text: The string.
	:returns: A pointer to the end of text.

	Example::

		(var aString[20], strPtr)
		StrCpy(aString "Hello World")
		= strPtr StrEnd(@aString)
*/
public string StrEnd(string text)
{
}

/*
	Returns the length of the specified string.

	:param string text: The string.
	:returns: The length of the string.

	Example::

		(var aString[40], strPtr)
		StrCpy(aString "Hello World")
		(if( < StrLen(aString) 100 )
			Print("The string is less than 100 characters")
		)
*/
public int StrLen(string text)
{
}

/*
	Analyzes the given string with the specified font to determine how much space it will take up on the screen when it's printed.
	maxWidth specifies how long each line can be. If it is not specified, then 192 is assumed.
	It returns the bounds of the rectangle in sizeRect.

	:param heapPtr sizeRect: The rectangle into which the bounds are returns.
	:param string text: The text.
	:param number font: The font number to use.
	:param number maxWidth: Optional maximum pixel width.

	sizeRect should be an array of 4 values. Indices 2 and 3 represent the width and height of the text.

	Example::

		(var sizeRect[4])
		TextSize(sizeRect "Hello World" 4 100)
		// gets the bounds of "Hello World" with FONT.004 with a maximum line width of 100
*/
public void TextSize(pointer sizeRect, string text, int font [, int maxWidth])
{
}

/*
	Unloads a resource from memory. If the resource is rsMEMORY, it frees the allocated memory specified by its pointer.

	:param number resourceType: rsVIEW, rsPIC, etc...
	:param number resourceNumber: The resource number, or the number of bytes to allocate in the case of rsMEMORY.

	Example::

		(var hView, memPtr)
		= hView Load(rsVIEW 100) // loads VIEW.100
		= memPtr Load(rsMEMORY 1024) // allocates 1024 bytes of memory
		UnLoad(rsVIEW 100) // unloads VIEW.000 from memory
		UnLoad(rsMEMORY memPtr) // frees memPtr from
*/
public void UnLoad(int resourceType, int resourceNumber)
{
}

/*
	Returns TRUE is the directory is valid, otherwise, FALSE.

	:param string directory: The directory.
	:returns: TRUE if the directory exists, otherwise FALSE.
*/
public bool ValidPath(string directory)
{
}

/*
	This waits (halts the game) for the specified number of ticks. Since the interpreter is on 60Hz beats, a Wait(60) is equivalent to one second.
	It returns the time passed between the end of the last Wait() call, and the current one.

	:param number ticks: The number of ticks to wait.

	Example::

		Wait(120) // Waits for two seconds

	See also: :func:`GetTime`.
*/
public int Wait(int ticks)
{
}

/*
	This appears to be unimplemented in Sierra's interpreter.

	.. IMPORTANT:: SCI1.1 only.
*/
public int ShiftScreen() {}

/*
	Palette lets you perform palette cycling animations, set the intensity of color
	ranges, and more. The various subfunctions will be described separately.

	.. IMPORTANT:: SCI1.1 only.

.. function:: Palette(palSET_INTENSITY startIndex endIndex intensity [setPalette])

	Sets the intensity of the range of colors.

	:param number startIndex: The inclusive starting index.
	:param number endIndex: The exclusive ending index.
	:param number intensity: Value from 0 to 100 representing the intensity.
	:param boolean setPalette: If TRUE, actually changes the palette value.

.. function:: Palette(palANIMATE startIndex endIndex speed)

	"Animates" the palette colors in a particular direction. This allows for palette cycling effects.

	:param number startIndex: The inclusive starting index.
	:param number endIndex: The exclusive ending index.
	:param number speed: A speed (lower numbers are faster) and direction (negative or positive).

	A single call to Palette(palANIMATE ...) will only shift the palette by one. It needs to be called
	repeatedly in a Script's doit() method to keep cycling the colors.

	Example::

		(method (doit)
			(super:doit())
			Palette(palANIMATE 192 198 -9)
		)

.. function:: Palette(palSET_FROM_RESOURCE resourceNumber [force])

	Sets the current palette from a palette resource.

	:param number resourceNumber: The palette resource number.
	:param nunber force: If force is 2, the palette set is forced.

	Example::

		Palette(palSET_FROM_RESOURCE 999 2)

.. function:: Palette(palSET_FLAG startIndex endIndex flag)

.. function:: Palette(palUNSET_FLAG startIndex endIndex flag)

	Sets or unsets a flag for a palette index.

	:param number startIndex: The inclusive starting index.
	:param number endIndex: The exclusive ending index.
	:param number flag: A flag. 1 indicates this palette color is *used*. 0 indicates it is not.

.. function:: Palette(palFIND_COLOR red green blue)

	Finds the closest palette index to a particular color.

	:param number red: The red component (0-255)
	:param number green: The green component (0-255)
	:param number blue: The blue component (0-255)
	:returns: The index of the color most closely matching the given RGB color.

	Example::

		= gLowlightColor Palette(palFIND_COLOR 159 159 159)

.. function:: Palette(palSAVE)

	Saves the current palette to be restored later.

	:returns: A cookie to use for restoring.

.. function:: Palette(palRESTORE cookie)

	Restores a palette.

	:param number cookie: A cookie returned from Palette(palSAVE).

*/
public void Palette(int palSET_INTENSITY, int startIndex, int endIndex, int intensity [, bool setPalette])
void Palette(int palANIMATE, int startIndex, int endIndex, int speed)
void Palette(int palSET_FROM_RESOURCE, int resourceNumber [, int force])
void Palette(int palSET_FLAG, int startIndex, int endIndex, int flags)
void Palette(int palUNSET_FLAG, int startIndex, int endIndex, int flags)
int Palette(int palFIND_COLOR, int red, int green, int blue)
int Palette(int palSAVE)
void Palette(int palRESTORE, int cookie)
{}

/*
.. function:: MemorySegment(fRestore address [size])

	.. IMPORTANT:: SCI1.1 only.

	MemorySegment provides access to a 256-byte block of memory that remains intact across restarts and restores.

	:param boolean fRestore: If 1, data is restored. If 0, data is saved.
	:param heapPtr address: Beginning of memory block to be saved or restored.
	:param number size: The size of the memory block to be saved (up to 256 bytes). Only specify this size when saving.
*/
public int MemorySegment() {}

// Not in SCI1.1
// public int Intersections() {}

/*
	Memory has several subfunctions that allow for inspecting, modifying and allocating memory dynamically.

	.. IMPORTANT::
		SCI1.1 only.

.. function:: Memory(memALLOC_CRIT byteCount)

	Allocates memory, and crashes the game if it fails.

	:param number byteCount: The number of bytes to allocate.
	:returns: A pointer to the memory block.

	Free the memory with Memory(memFREE).

	Example::

		(method (setName theName)
			= name Memory(memALLOC_CRIT (+ StrLen(theName) 1))
			StrCpy(name theName)
		)

.. function:: Memory(memALLOC_NONCRIT byteCount)

	Allocates memory, returns 0 if it fails.

	:param number byteCount: The number of bytes to allocate.
	:returns: A pointer to the memory block.

	Example::

		(if (not (= text Memory(memALLOC_NONCRIT 20)))
			TextPrint("Couldn't allocate memory.")
		)

	Free the memory with Memory(memFREE).

.. function:: Memory(memFREE address)

	Frees memory allocated by memALLOC or memALLOC_NONCRIT.

	:param heapPtr address: A pointer to the memory block.

	Example::

		Memory(memFREE blah)

.. function:: Memory(memCPY dest source byteCount)

	Copies memory from one location to another.

	:param heapPtr dest: Destination address.
	:param heapPtr source: Source address.
	:param number byteCount: The number of bytes to copy.

.. function:: Memory(memPEEK address)

	Returns the 16-bit value at the address. It's important to note that addresses point
	to 16-bit values, so the address of two adjacent values in memory will be separated by 2.

	:param heapPtr address: A memory address.
	:returns: The value at the address.

	Example::

		(= point Memory(memPEEK (polyPointArray + (* 2 pointIndex))))

.. function:: Memory(memPOKE address value)

	Sets the value at a memory location.

	:param heapPtr address: A memory address.
	:param number value: The value to put at this address.

	Example::

		Memory(memPOKE (+ polyPointArray 2) 137)

*/
public void Memory(int memFREE, int address)
int Memory(int memALLOC_CRIT, int byteCount)
int Memory(int memALLOC_NONCRIT, int byteCount)
void Memory(int memCOPY, int destinationAddress, int sourceAddress, int byteCount)
int Memory(int memPEEK, int address)
int Memory(int memPOKE, int address, int value)
{}

/*
	Unknown purpose. Never called by Sierra games.

	.. IMPORTANT:: SCI1.1 only.
*/
public int ListOps() {}

/*
	FileIO handles all file operations in SCI1.1. The :class:`File` class wraps
	all these calls, and should generally be used instead.

	.. IMPORTANT:: SCI1.1 only.

.. function:: FileIO(fiOPEN filename mode)

	Opens a file.

	:param string filename: The filename.
	:param number mode: An open mode described below.
	:returns: A handle to the file if successful. Otherwise NULL.

	The modes are as follows:

	============= =======================================================================
	Mode          Description
	============= =======================================================================
	fOPENFAIL     open or fail: Try to open file, abort if not possible
	fOPENCREATE   open or create: Try to open file, create it if it doesn't exist
	fCREATE       create: Create the file, destroying any content it might have had
	============= =======================================================================


.. function:: FileIO(fiCLOSE handle)

	Closes the specified file.

	:param number handle: A handle returned by FileIO(fiOPEN).

.. function:: FileIO(fiREAD handle outBuffer byteCount)

	Reads a number of bytes from a file.

	:param number handle: A handle returned by FileIO(fiOPEN).
	:param heapPtr outBuffer: A buffer into which the bytes are placed (at least byteCount big).
	:param number byteCount: The number of bytes to read.
	:returns: The number of bytes actually read.

.. function:: FileIO(fiWRITE handle inBuffer byteCount)

	Writes data to a file.

	:param number handle: A handle returned by FileIO(fiOPEN).
	:param heapPtr inBuffer: A buffer containing the data to be written.
	:param number byteCount: The number of bytes to write.

.. function:: FileIO(fiUNLINK filename)

	Deletes a file.

	:param string filename: The filename to delete.

.. function:: FileIO(fiREAD_STRING outText byteCount handle)

	Reads a string from a file.

	:param heapPtr outText: A buffer into which string is placed (at least byteCount big).
	:param number byteCount: The number of bytes to read.
	:param number handle: A handle returned by FileIO(fiOPEN).

.. function:: FileIO(fiWRITE_STRING handle inString byteCount)

	Writes a string to a file.

	:param handle handle: A handle returned by FileIO(fiOPEN).
	:param heapPtr inText: The string to write.

.. function:: FileIO(fiSEEK handle offset whence)

	Seeks to a position in the file.

	:param number handle: A handle returned by FileIO(fiOPEN).
	:param number offset: The offset.
	:param number whence: The point to which the offset is relative.

	======== ========================
	Whence values
	---------------------------------
	Values   Position
	======== ========================
	0        Beginning
	1        Current position
	2        End
	======== ========================

.. function:: FileIO(fiFIND_FIRST filenameMask outBuffer fileAttributes)

	Begins a file enumeration in the current directory. Continue the enumeration
	using FileIO(fiFIND_NEXT).

	:param string filenameMask: A file name filter string, like "*.txt".
	:param string outBuffer: The buffer that receives the first filename.
	:param number fileAttributes: Attributes of the file. Pass 0 for regular files.
	:returns: TRUE if the first file was found, otherwise FALSE.

.. function:: FileIO(fiFIND_NEXT outBuffer)

	Returns the next file in an enumeration begun by fiFIND_FIRST.

	:param string outBuffer: The buffer that receives the next filename.
	:returns: TRUE if there was another file, otherwise FALSE.

.. function:: FileIO(fiEXISTS filename)

	Checks whether a file exists.

	:param string filename: The filename.
	:returns: TRUE if the file exists.

.. function:: FileIO(fiRENAME oldFilename newFilename)

	Renames a file.

	:param string oldFilename: The current filename.
	:param string newFilename: The new filename.
*/
public int FileIO(int fiOPEN, string filename, int mode)
void FileIO(int fiCLOSE, int handle)
int FileIO(int fiREAD, int handle, string outBuffer, int byteCount)
int FileIO(int fiWRITE, int handle, string inBuffer, int byteCount)
int FileIO(int fiUNLINK, string filename)
int FileIO(int fiREAD_STRING, string outText, int byteCount, int handle)
int FileIO(int fiWRITE_STRING, int handle, string inText)
int FileIO(int fiSEEK, int handle, int offset, int whence)
int FileIO(int fiFIND_FIRST, string filenameMask, string outBuffer, int fileAttributes)
int FileIO(int fiFIND_NEXT)
int FileIO(int fiEXISTS, string filename)
int FileIO(int fiRENAME, string oldFilename, string newFilename)
{}

/*
	DoAudio manages playback of audio resources. The various subfunctions will be discussed separately.

	.. IMPORTANT::
		SCI1.1 only.

.. function:: DoAudio(audPLAY resourceNumber)

.. function:: DoAudio(audPLAY moduleNumber noun verb condition sequence)

	Starts a digital audio sample. Variations are provided for both
	audio resources (described by a single resource number) and audio36 resources
	(described by a module number and a noun/verb/condition/sequence tuple. The latter
	are used for speech samples associated with message resources.

	:param number resourceNumber: The resource number.
	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.
	:returns: The sample length in ticks.

	Example::

		DoAudio(audPLAY 107)

.. function:: DoAudio(audWPLAY resourceNumber)

.. function:: DoAudio(audWPLAY moduleNumber noun verb condition sequence)

	Loads a digital sample but does not play it. It returns the length of the sample
	in ticks. This can be useful if some game logic needs to be aware of the length of the audio.
	
	Variations are provided for both
	audio resources (described by a single resource number) and audio36 resources
	(described by a module number and a noun/verb/condition/sequence tuple. The latter
	are used for speech samples associated with message resources.

	:param number resourceNumber: The resource number.
	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.
	:returns: The sample length in ticks.

	Example::

		(Timer:setTicks(self DoAudio(audWPLAY gRoomNumber noun verb condition seq)))

.. function:: DoAudio(audSTOP)

	Stops the currently playing digital audio sample.

.. function:: DoAudio(audPAUSE)

	Pauses the currently playing digital audio sample.

.. function:: DoAudio(audRESUME)

	Resumes the currently playing digital audio sample.

.. function:: DoAudio(audPOSITION)

	Returns the position of the currently playing digital audio sample.

.. function:: DoAudio(audRATE rate)
	
	Sets the audio rate.
	
.. function:: DoAudio(audVOLUME volume)

	Sets the volume of the currently playing audio sample.

	:param number volume: A value between 0 and 127.

.. function:: DoAudio(audLANGUAGE languageId)

	Sets the audio language.

.. function:: DoAudio(audCD [params...])

	Controls the CD-audio functions.

*/
public int DoAudio(int audWPLAY, int resourceNumber)
int DoAudio(int audWPLAY, int moduleNumber, int a, int b, int c, int d)
int DoAudio(int audPLAY, int resourceNumber)
int DoAudio(int audWPLAY, int moduleNumber, int a, int b, int c, int d)
void DoAudio(int audSTOP)
void DoAudio(int audPAUSE)
void DoAudio(int audRESUME)
int DoAudio(int audPOSITION)
void DoAudio(int audRATE, int rate)
int DoAudio(int audVOLUME, int volume)
int DoAudio(int audLANGUAGE)
int DoAudio(int audCD, ...)
{}

/*
	DoSync handles lip-sync functions.

	.. IMPORTANT:: SCI1.1 only.

.. function:: DoSync(syncSTART syncObject moduleNumber noun verb condition sequence)

.. function:: DoSync(syncSTART syncObject resourceNumber)

	Associates an object with a lip-sync resource.

	:param heapPtr syncObject: An instance of :class:`Sync` that will receive lip-sync information.
	:param number resourceNumber: The resource number.
	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.

.. function:: DoSync(syncNEXT syncObject)

	Updates the :class:`Sync` object with current information from the lip-sync resource.

	:param heapPtr syncObject: An instance of :class:`Sync` that will receive lip-sync information.

.. function:: DoSync(syncSTOP)

	Stops the lip-sync operation.

*/
public void DoSync(int syncSTART, int syncObject, int a, int b, int c, int d)
void DoSync(int syncSTART, int syncObject)
void DoSync(int syncNEXT, int syncObject)
void DoSync(int syncSTOP)
{}

/*
.. function:: AvoidPath(x y polygon)

	.. IMPORTANT:: SCI1.1 only.

	Determines if a point is inside the given polygon.

	:param number x: The x coordinate of the point.
	:param number y: The y coordinate of the point.
	:param heapPtr polygon: An instance of :class:`Polygon`.
	:returns: TRUE if the point is inside the polygon, otherwise FALSE.

.. function:: AvoidPath(xStart yStart xEnd yEnd polygons polyCount [options])

	Calculates a path between two points given the polygon obstacles. Returns a memory
	address pointing to an array of points. The memory address returned must be freed with Memory(memFREE).

	The returned array consists of (x, y) pairs of points, followed by a sentinel ending point ($7777, $7777).

	:param number xStart: The x coordinate of the starting point.
	:param number yStart: The y coordinate of the starting point.
	:param number xEnd: The x coordinate of the destination.
	:param number yEnd: The y coordinate of the destination.
	:param k_list polygons: A list of polygons.
	:param number polyCount: The number of polygons in the list.
	:param number options: Optimization levels. Optimization level 0 is for keyboard support, and changes some of the polygons.
	:returns: A list of points comprising the path, or NULL on failure. The points should be freed by Memory(memFREE).

*/
public int AvoidPath(int xStart, int yStart, Polygon polygon)
int AvoidPath(int xStart, int yStart, int xEnd, int yEnd, k_list polygons, int polyCount [,int options])
{}

/*
.. function:: Sort(source dest orderFunction)

	.. IMPORTANT:: SCI1.1 only.

	Sorts a list and puts the result into another list.

	:param k_list source: The list of items to sort.
	:param k_list dest: The destination list. The list may be the same as the source list.
	:param heapPtr orderFunction: An instance of an object with a doit() method (e.g. :class:`Code`) that returns a numerical value indicating order.

	Example::

		(instance sortByDistanceToEgo of Code
			(properties)
			(method (doit theObj)
				return (send gEgo:distanceTotheObj))
			)
		)

		// Then somewhere in the script:
		Sort(myEventHandler myEventHandler sortByDistanceToEgo)	
*/
public int Sort() {}

/*
	It is not recommended to use this function, as it is not supported in ScummVM (and not used in any Sierra games).

	.. IMPORTANT:: SCI1.1 only.
 */
public int ATan() {}

/*
.. function:: Lock(resourceType resourceNumber [lock])

	.. IMPORTANT:: SCI1.1 only.

	Locks or unlocks resources of a certain type. Locking presuambly prevents a resource
	from being unloaded, so it is likely a performance optimization.

	:param number resourceType: A resource type, e.g. rsVIEW, rsPIC, etc...
	:param number resourceNum: A resource number, or $ffff for all resources of that type.
	:param boolean lock: If TRUE or unspecified, the resource(s) is locked. Otherwise they are locked.
*/
public int Lock() {}

/*
	Processes a multilanguage string based on the current language settings and returns a string that is ready to be displayed.

	.. IMPORTANT:: SCI1.1 only.

	:param string outBuffer: The results are placed here.
	:param string inString: The string to split.
	:param string separator: The separator string.
	:returns: The outBuffer.
*/
public int StrSplit(string outBuffer, string inString [,string separator])
{}

/*
	Retrieves message resource information. Messages are what is spoken by in-game characters. See :doc:`/messages`.

	.. IMPORTANT:: SCI1.1 only.

.. function:: Message(msgGET moduleNumber noun verb condition sequence textBuffer)

	Gets the text for the specified message resource, and returns the talker number.

	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.
	:param string textBuffer: The buffer that receives the message text.
	:returns: A talker number, or 0 if it failed.

	Example::

		(var temp0[100])
		Message(msgGET 0 12 0 0 1 @temp0)

.. function:: Message(msgNEXT textBuffer)

	Gets the text for the message resource that follows the one previously obtained by msgGET. The following message
	is the one with the same moduleNumber/noun/verb/condition tuple, but an incremented sequence number. If no such
	message exists, then the search continues at the message given by the last stack frame.

	:param string textBuffer: The buffer that receives the message text.
	:returns: A talker number, or 0 if it failed.

.. function:: Message(msgLAST_MESSAGE outBuffer)

	Gets the tuple of the last returned message. This consists of 5 16-bit values:
	moduleNumber, noun, verb, condition and sequence.

	:param heapPtr outBuffer: A buffer large enough to hold 12 bytes (2 for the null terminator)

	Example::

		(var buffer, modNum, noun, verb, condition, case)
		= buffer Memory(memALLOC_CRIT 12)
		Message(msgLAST_MESSAGE buffer)
		= modNum GetValueAt(buffer 0)
		= noun GetValueAt(buffer 1)
		= verb GetValueAt(buffer 2)
		= condition GetValueAt(buffer 3)
		= case GetValueAt(buffer 4)
		DoAudio(audPLAY modNum noun verb condition case)

.. function:: Message(msgSIZE moduleNumber noun verb condition sequence)

	Gets the size needed to store the message text (including terminating null).

	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.
	:returns: The size in bytes needed to store the message text.

	Example::

		(var theSize, title)
		= theSize Message(msgSIZE modNum noun verb condition seq)
		(if (theSize)
			= title Memory(memALLOC_CRIT theSize)
			Message(msgGET modNum noun verb condition seq title)
		)

.. function:: Message(msgREF_NOUN moduleNumber noun verb condition sequence)

.. function:: Message(msgREF_VERB moduleNumber noun verb condition sequence)

.. function:: Message(msgREF_COND moduleNumber noun verb condition sequence)

.. function:: Message(msgPUSH)

.. function:: Message(msgPOP)
*/
public void Message(int msgGET [, int moduleNumber, int noun, int verb, int condition, int sequence, string outBuffer])
int Message(int msgSIZE [, int moduleNumber, int noun, int verb, int condition, int sequence])
void Message(int msgNEXT [, string outBuffer])
int Message(int msgREF_NOUN [, int moduleNumber, int noun, int verb, int condition, int sequence])
int Message(int msgREF_VERB [, int moduleNumber, int noun, int verb, int condition, int sequence])
int Message(int msgREF_COND [, int moduleNumber, int noun, int verb, int condition, int sequence])
void Message(int msgPUSH)
void Message(int msgPOP)
{}

/*
	Checks whether a pixel in a cel is transparent. This can be used to enhance hit testing on game objects,
	especially if they have big holes in them.

	:param number view: View number.
	:param number loop: Loop number.
	:param number cel: Cel number.
	:param number x: The x coordinate in the view, relative to the top left.
	:param number y: The y coordinate in the view, relative to the top left.
	:returns: TRUE if the pixel is transparent.
*/
public bool IsItSkip(int view, int loop, int cel, int x, int y)
{}

/*
.. function:: MergePoly(points polygons polyCount)

	.. IMPORTANT:: SCI1.1 only.

	This takes a polygon, and extends it to also cover any polygons from the
	input list with which it intersects. Any of those polygons so covered
	from the input list are marked by adding 0x10 to their type field.

	:param heapPtr points: Buffer of polygon points, with a ($7777, $7777) sentinel point at the end.
	:param k_list polygons: A list of polygons.
	:param number polyCount: The number of polygons in the list.

	Example::

		(var newPoints)
		(= newPoints MergePoly(points (send obstacles:elements) (send obstacles:size)))
		(if (newPoints)
			// Do something with the new points, etc...
			Memory(memFREE newPoints)
		)
*/
public int MergePoly(var points, k_list polygons, int polyCount)
{}

/*
.. function:: ResCheck(resourceType moduleNumber noun verb condition sequence)

.. function:: ResCheck(resourceType resourceNumber)

	.. IMPORTANT:: SCI1.1 only.

	Checks if a resource is present.

	:param number resourceType: The type of the resource (rsVIEW, rsPIC, rsAUDIO36, etc...)
	:param number resourceNumber: The resource number.
	:param number moduleNumber: The module number (room number).
	:param number noun: The message noun.
	:param number verb: The message verb.
	:param number condition: The message condition.
	:param number sequence: The message sequence number.
	:returns: TRUE if the resource is present, otherwise FALSE.

	Example::

		// Do we have an audio resource for this message?
		(if (ResCheck(rsAUDIO36 moduleNumber noun verb condition sequence))
			DoAudio(audPLAY moduleNumber noun verb condition sequence)
		)

*/
public int ResCheck() {}

/*
	Merges/inserts any palette embedded in the specified view into the current palette.

	:param number view: A view resource number.
*/
public int AssertPalette(int view) {}

/*
.. function:: TextColors([colors ...])

	.. IMPORTANT:: SCI1.1 only.

	Sets the palette color indices used to render message text.

	:param number colors: One or more color indices.

	Example::

		// By default, render messages as color 0.
		// Render messages with the |c1| tag as color 15.
		// Render messages with the |c2| tag as color 52.
		// Render messages with the |c3| tag as color 53.
		TextColors(0 15 52 53)

*/
public int TextColors(...) {}

/*
.. function:: TextFonts([fonts ...])

	.. IMPORTANT:: SCI1.1 only.

	Sets the fonts used to render message text.

	:param number fonts: One or more font resource numbers.

	Example::

		// By default, render messages in font 1605.
		// Render messages with the |f1| tag in font 900.
		// Render messages with the |f2| tag in font 901.
		TextColors(1605 900 901)
*/
public int TextFonts(...) {}

/*
	This was used for debugging.
*/
public int Record() {}

/*
	This was used for debugging.
*/
public int PlayBack() {}

/*
	Plays a .seq movie. This is not supported by the Sierra interpreter included in the SCI1.1 template game.	

	:param string filename: The movie file to play.
*/
public int ShowMovie(string filename) {}

/*
	Used by KQ6's intro. This is not supported by the Sierra interpreter included in the SCI1.1 template game.	
*/
public int SetVideoMode(int number) {}

/*
	Sets a string to be displayed when the game is quit.
*/
public int SetQuitStr(string message) {}

/*
	This was used for debugging.
*/
public int DbugStr() {}

/*
	PalVary manages transitions between the current palette and a new palette. It has a number of different subfunctions
	which will be described separately.

	.. IMPORTANT:: SCI1.1 only.

.. function:: PalVary(pvINIT resourceNumber ticks [stepStop direction])

	Begins a transition to a new palette. This only needs to be called once.

	:param number resourceNumber: The palette resource number.
	:param number ticks: The number of ticks between each step in the transition (60 ticks is one second).
	:param number stepStop: How far along the transition to go, ranging from 0-64, where 64 is the complete transition. The default is 64.
	:param number direction: 1 for forward, -1 for reverse.

	Example::

		PalVary(pvINIT targetPalette 1 64 3)

.. function:: PalVary(pvUNINIT)

	Stops a palette transition. Before performing other palette effects, an existing transition must be stopped.

	Example::

		(method (doit)
			(super:doit())
			(if (== 64 PalVary(pvGET_CURRENT_STEP))
				PalVary(pvUNINIT)
				// The transition is now done...
			)
		)

.. function:: PalVary(pvREVERSE [ticks stepStop direction])

	Reverses an existing palette transition.

	:param number ticks: The number of ticks between each step in the transition (60 ticks is one second).
	:param number stepStop: How far along the transition to go, ranging from 1-64, where 64 is the complete transition.
	:param number direction: 1 for forward, -1 for reverse.

.. function:: PalVary(pvGET_CURRENT_STEP)

	Returns the current step of the transition, ranging between 0 and 64. 64 indicates the transition is complete.

	:returns: The current step (between 0 and 64).

.. function:: PalVary(pvCHANGE_TARGET resourceNumber)

	Changes the target palette of the transition.

	:param number resourceNumber: The palette resource number.

.. function:: PalVary(pvCHANGE_TICKS ticks)

	Sets the number of ticks between each step of the palette transition.

	:param number ticks: The number of ticks between each step in the transition (60 ticks is one second).

.. function:: PalVary(pvPAUSE_RESUME fPause)

	Pauses or resumes a palette transition.

	:param boolean fPause: If TRUE, the transition is paused. If FALSE, the transtion is resumed.

*/
public void PalVary(int pvINIT, int resourceNumber [, int stepStop, int direction])
void PalVary(int pvUNINIT)
void PalVary(int pvREVERSE [, int ticks, int stepStop, int direction])
int PalVary(int pvGET_CURRENT_STEP)
void PalVary(int pvCHANGE_TARGET, int resourceNumber)
void PalVary(int pvCHANGE_TICKS, int ticks)
void PalVary(int pvPAUSE_RESUME, bool pause)
{}

/*
.. function:: Platform(subFunction)

	.. IMPORTANT:: SCI1.1 only.

	Retrieves platform information.

	:param number subFunction: One of the sub functions listed below.
	:returns: A value depending on the sub function.

	============= ============== ================================================
	SubFunction   Description    Returns
	============= ============== ================================================
	1             Get CD speed   Returns the CD speed
	3             CD check       Unknown
	4             Get platform   1 for DOS, 2 for Windows.
	5             Is not hi-res? TRUE if not on a hi-res platform.
	6             Is hi-res?     TRUE if on a hi-res platform, otherwise FALSE
	7             Is windows?    TRUE if on Windows, otherwise FALSE.
	============= ============== ================================================
*/
public void Platform(int subop)
{}

